/*
 * Copyright (c) 2016 BreizhCamp
 * [http://breizhcamp.org]
 *
 * This file is part of CFP.io.
 *
 * CFP.io is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

(function(window, angular, document, undefined) {
    'use strict';

    angular.module('ngResourceRetries', ['ng', 'ngResource']).
    provider('resourceRetries', function() {
        var common = {
            retryTimeout: 100,
            retryMax: 3
        };

        this.options = function(args) {
            common = angular.extend(common, args);
        };

        // I want to override/wrap all the method generated by the $resource .. I managed don't see an another way to d
        this.$get = ['$timeout', '$q', '$resource', function($timeout, $q, $resource) {
            function resourceFactory(url, paramDefaults, actions, options) {
                // create the resource to use in our wrapper
                var ngResource = $resource(url, paramDefaults, actions);
                var res = {};
                var generateWrapper = function(methodName) {
                    return function() {
                        var defer = $q.defer();
                        var inc = 0;
                        var args = arguments;

                        function retry(inc) {
                            /*jshint validthis: true */
                            var retryMax = common.retryMax,
                                retryTimeout = common.retryTimeout;
                            if (options && angular.isNumber(options.retryMax)) {
                                retryMax = options.retryMax;
                            }
                            if (options && angular.isNumber(options.retryTimeout)) {
                                retryTimeout = options.retryTimeout;
                            }

                            inc += 1;
                            if (inc <= retryMax) {
                                ngResource[methodName].apply(this, args).$promise.then(function(data) {
                                    defer.resolve(data);
                                }, function() {
                                    $timeout(function() {
                                        retry(inc);
                                    }, retryTimeout);
                                });
                            } else {
                                ngResource[methodName].apply(this, args).$promise.then(function(data) {
                                    defer.resolve(data);
                                }, function(error) {
                                    defer.reject(error);
                                });
                            }
                        }

                        retry(inc);

                        return {
                            '$promise': defer.promise
                        };
                    };
                };

                angular.forEach(ngResource.prototype, function(value, method) {
                    // we slice(1) to delete the $
                    res[method.slice(1)] = generateWrapper(method.slice(1));
                });

                return res;
            }

            return resourceFactory;
        }];
    });

})(window, window.angular);
